\documentclass{polytech/polytech}
      
\usepackage{lipsum}
  
\typereport{prddi5}       

\reportyear{2018-2019}   

\title{Mise en oeuvre des outils de parallèlisme sur un programme donné}
%\subtitle{Il peut y avoir un sous titre mais ce n'est pas obligatoire}
\reportlogo{polytech/polytech}
           
\student[di5]{Ayoub}{IDEL}{ayoub.idelmahjoub@etu.univ-tours.fr}

\academicsupervisor[di]{Patrick}{MARTINEAU}{patrick.martineau@univ-tours.com}

\industrialsupervisor{Patrick}{MARTINEAU}{patrick.martineau@univ-tours.com}

\company[polytech/polytech]{Polytech'Tours}{ 64 Avenue Jean Portalis,\\ 37200 Tours}{polytech.univ-tours.fr}

\confidential

\resume{\lipsum[1]}
\motcle{mot}
\motcle{clé}            
\motcle{deux mots}
             
\abstract{\lipsum[1-2]}
\keyword{word}
\keyword{key}
\keyword{two words}
\keyword{fourth word}


\posterblock{Objectifs}{
Lorem ipsum dolor sit amet:
\begin{itemize}
\item Vestibulum tincidunt ipsum
\item In dictum elit condimentum.
\item Suspendisse ornare orci.
\end{itemize}
Aliquam porta mi ut justo pellentesque porta.
}{polytech/polytech}{dictum elit condimentum}

\posterblock{Mise en \oe{}uvre}{
Mauris consectetur, et auctor mi \emph{fermentum}.  Etiam venenatis augue neque, ac ullamcorper sodales sit amet.
\begin{center}
\begin{tabular}{|c|c|c||c|}
\hline
1&2&3&4\\
\hline
\end{tabular}
\end{center}
Fusce aliquet sed sapien \textbf{tempor} facilisis. Nunc mi urna, cursus a ullamcorper quis, laoreet id felis.  
}{polytech/polytech}{}%Encore le logo au cas où on ne l'aurait pas vu}

\posterblock{Résultats attendus}{
\begin{itemize}
\item Quisque \textbf{dictum} diam in feugiat
\item Proin quam nec, gravida mi
\item \textbf{\emph{Suspendisse} truc bidul} vehicula magna
\item Nulla sagittis diam congue sagittis
\item Donec auctor a non nisi
\item Vestibulum quis \emph{rhoncus} risus
\end{itemize}%
}{polytech/polytech}{auctor a non nisi\\auctor a non nisi}
    
\bibliography{biblio}















\newacronym{gflops}{G flops}{L'unité flop est une mesure largement utilisée de la performance d’accès à la mémoire. Elle est égale à la vitesse à laquelle une machine peut effectuer des opérations à virgule flottante simple précision, c’est-à-dire combien de ces opérations l’ordinateur peut effectuer en une unité de temps (seconde dans notre cas)}
\newacronym{}{}{Question à Choix Multiple}
\newacronym{qcu}{QCU}{Question à Choix Unique}
\newacronym{ent}{ENT}{Environnement Numérique de Travail}
\newacronym{iu}{iu}{Interface Utilisateur}
\newacronym{ui}{UI}{User Interface}
\newacronym{gui}{GUI}{Graphical User Interface}
\newacronym{mvc}{MVC}{Model View Controller}
\newacronym{gorm}{GORM}{Groovy Object Relational Mapping}
\newacronym{bdd}{BDD}{Base De Données}
\newacronym{db}{DB}{Data Base}
\newacronym{jmx}{JLX}{Java Management Extensions}
\newacronym{uml}{UML}{Unified Modeling Language}
\newacronym{acm}{ACM}{Auto Multiple Choice}
\newacronym{betsy}{BETSY}{Bayesian Essay Test Scoring sYstem}
    
    
\newglossaryentry{Calcul parallèle}
{
	name=calcul parallèle,
	description={se définit comme la pratique consistant à employer un nombre de processeurs associés, communiquant entre eux pour résoudre rapidement de gros problèmes.}
}
\newglossaryentry{moodle}
{
	name=moodle,
	description={Moodle est une platforme d'apprentissage Open-Source}
}
\newglossaryentry{opensource}
{
	name=Open Source,
	description={Libre de droit, dont les codes sources sont disponibles et modifiable librement}https://en.wikipedia.org/wiki/List_of_learning_management_systems
}
\newglossaryentry{module}
{
	name=module,
	description={Un module est une entité regroupant un groupe. Par exemple, la création/édition/exécution d'un QCM est un module différent de celui accordeur}
}
\newglossaryentry{execution}
{
	name=exécution,
	description={L'exécution d'une question est le fait d'y répondre}
}
\newglossaryentry{question}
{
	name=question,
	description={Une question contient une sortie (texte, image, son, ...) qui demande à l'utilisateur de fournir une entrée (texte, image, son, ...) pour traiter cette entrée comme étant la réponse à la demande faite en sortie}
}
\newglossaryentry{reponse}
{
	name=réponse,
	description={Equivalent du traitement}
}
\newglossaryentry{quiz}
{
	name=quiz,
	description={Un quiz est un reccueil de questions}
}
\newglossaryentry{traitement}
{
	name=traitement,
	description={Le traitement est le fait de corriger l'entrée d'une question. C'est le mécanisme qui va dire si l'entrée est correcte, n'est pas correcte ou s'il faut une intervention humaine pour traiter le problème}
}





































\begin{document}

    
    \part{Les premiers trucs dont je vais parler}                
    
    \chapter{Introduction}   
    Ce document constitue les spécifications de Projet de Recherche et de Développement  « Parallèlisme » .\\\\
    Ce sujet de projet est proposé par Monsieur Patrick MARTINEAU qui représente le MOA (Maitrise d'ouvrage) au sein de l’École Polytechnique de l’Université de Tours. Le projet sera réalisé par Ayoub IDEL, élève ingénieur en 5ème année à Polytech Tours.
    
        \section{Contexte}
        
        Presque tous les calculs effectués au cours des quarante premières années de l’histoire de l’informatique pourraient être appelés séquentiel. \\\\
        Une des caractéristiques du calcul séquentiel est qu’il utilise un seul processeur pour résoudre un problème (ici, le terme «problème» est utilisé au sens large, c’est-à-dire que l’on exécute une seule tâche). Ces processeurs étaient devenus de plus en plus rapides et moins cher au cours des trois premières décennies, en doublant leur vitesse tous les deux ou trois ans. Cependant, en raison de la limite imposée par la vitesse de la lumière, il semble extrêmement improbable que nous puissions construire des Ordinateurs ne contenant qu'un seul processeur et pouvant atteindre des performances nettement supérieures à 1 000 000 000 d'opérations par seconde (Gflops).\\\\
        Toutefois, si l’on prend en compte l’appétit sans cesse croissant de la puissance informatique pour le calcul (c'est-à-dire pour résoudre plus rapidement des problèmes plus importants), il devient nécessaire de choisir une autre voie pour le calcul séquentiel. Le calcul parallèle semble être l’alternative la plus prometteuse si ce n’est la seule.\\\\
        Le calcul parallèle se définit comme la pratique consistant à employer un nombre de processeurs associés, communiquant entre eux pour résoudre rapidement de gros problèmes. Il est rapidement devenu un domaine important de la science informatique. Au cours des cinq dernières années, le calcul parallèle a pris de l'ampleur et confirme que la plupart des recherches menées dans les domaines de la conception et de l'analyse d'algorithmes, de langages informatiques, d'applications informatiques et d'architectures informatiques se situent dans son contexte. De nouvelles machines parallèles à la nouvelle architecture sont construites chaque an.\\\\
        Nous allons exploiter le parallèlisme dans ce projet afin d'avoir les meilleurs résultats et temps d'exécution possibles d'un algorithme.\\\\
        Dans ce rapport, le premier chapitre décrit le contexte de la réalisation, y compris l’objectif du logiciel, l’hypothèse et la méthodologie utilisée. Le deuxième chapitre présente les descriptions générales du logiciel sur l’environnement, les utilisateurs ainsi que la structure générale du systume,  ensuite nous allons exposer en détaille les fonctionnalités. Le troisième chapitre présente l'état de l'art relatif à ce projet. Le quatrième chapitre explique les analyses faites sur le problème choisi. Le chapitre 5 explique en détails l’algorithme proposé et des améliorations possibles. Quant au sixième chapitre, nous mettrons en place un bilan générale du projet.\\\\
        La partie annexe traite les points suivants : planification, spécifications fonctionnelles et non-fonctionnelles détaillées, gestion de projet, documents d’installation et d’utilisation, enfin les différents tests à savoir : tests unitaires, fonctionnels et de performance.
        
        \section{Objectifs}
        
        sur un programme donné, je dois mettre en oeuvre les différentes technologies du parallèlisme : multithread (OpenMP), multicore(CUDA), multiprocessus (MPI).\\\\
        À l'aide de ces outils, je dois résoudre le problème de la séquence la plus courte en évaluant toutes les combinaisons possibles. La complexité est de O(n!), le problème est NP-difficile.\\\\
        Dans un premier temps, je dois mettre en place un algorithme sequentiel qui résout le problème, ensuite y affecter quelques modifications afin de le parallèliser.\\\\
        Dans un deuxième temps, je dois adapter l'algorithme pour qu'il soit fonctionnel sur réseau. En effet, un processus "serveur" gère la file d'attente des séquences à évaluer et les distribues par lot. En ce qui concerne la distribution ou l'évaluation des lots, plusieures stratégies peuvent etre mise en place, comme :
        \begin{itemize}
            \item évaluation par demande
            \item mécanisme de reporting
            \item taille des lots
            \item LIFO ...
        \end{itemize}
        Lorsque les différents calculs sont attribués à différents clients, des fichiers de log et d'erreurs doivent exister pour la reprise de ces calculs en cas d'échec d'un client ou d'un serveur.\\\\
        Dans un troisième temps, je dois programmer une API pour aider au déploiment parallèle des recherches exhaustives au quasi-exhaustives.

        \section{Hypothèses}
        
        \begin{enumerate}
            \item Quant au projet, nous avons supposé que toutes les machines (Clients et serveur) sont disponibles et fonctionnelles.\\
            \item Les différents programmes sont composés sur un ensemble de fichiers d'instance fixe\\
            \item Le langage de programmation choisi est C, vu que les différentes bibliothèques et frameworks \textbf{(OpenMP, CUDA, MPI, ...)} fonctionnent correctement avec ce langage de programmation.
        \end{enumerate}
        
        \section{Bases méthodologiques}
        
        \begin{enumerate}
            \item Les outils utilisés
            \begin{itemize}
                \item \textbf{Trello} : outil visuel et facile à utiliser pour gérer les différentes taches du projet. Il est entièrement gratuit
                \item \textbf{Astah UML} : outil gratuit pour produire les différents diagrammes (use case diagram, sequentiel diagram, ...)
                \item \textbf{Gantt} : outil utilisé pour ordonner et visualiser les diverses taches dans le temps. Il permet de représenter graphiquement l'avancement du projet.\\\\
            \end{itemize}
            \item Les étapes suivies pour la gestion de projet
            \begin{itemize}
                \item \textbf{Compréhension du projet : }
                Dans première phase d'étude, j'analyse le besoin du client et comprendre les différents points
                \item \textbf{Conception et plannification : }
                Définir avec détails ce qui doit être fait, comment et avec quels moyens, et planifier dans le temps les étapes ainsi que les taches.
                \item \textbf{Réalisation du projet : }
                Mettre en oeuvre concrète des éléments planifiés, programmation ...
                \item \textbf{Bilan final : }
                Rédiger un bilan de synthèse sur le déroulement du projet et les résultats attendus\\
            \end{itemize}
        \end{enumerate}
        
        Le modèle suivi pour la gestion de projet ainsi que la plannification sera décrite dans la partie \textbf{"Planification"} dans l'Annexe.
        
        
        
        
        
        
    \chapter{Description générale}
    
    Dans ce chapitre, nous allons présenter l'environnement utilisé pour réalisér le projet, puis les caractéristiques des utilisateurs, ensuite les fonctionnalités du système et enfin la structure générale du système.
    
        \section{Environnement du projet}
        
        L'environnement utilis
        
        \section{Caractéristiques des utilisateurs}
        \section{Fonctionnalités du système}
        \section{Structure générale du système}
    
    \chapter{État de l'art}
    
        \section{}
        \section{}
        \section{}
    
    \chapter{Analyse et conception}
    
    \chapter{Mise en oeuvre}
    
        \section{Introduction de l'algorithme proposé}
        \section{Version initiale de l'algorithme proposé}
        \section{Amélioration de l'algorithme proposé}
        \section{Version améliorée de l'algorithme}
    
    \chapter{Conclusion}
    
        \section{Bilan du semestre 9}
        \section{Planning du semestre 10}
        \section{Bilan du semestre 10}
        \section{Bilan sur la qualité}
        \section{Bilan auto-critique}
    
    
    
    \appendix   
    
    \chapter{Planification}
    
        \section{Apercu de gestion de projet}
        \section{Découpage des taches}
    
    \chapter{Spécifications fonctionnelles}
    
    \chapter{Spécifications non fonctionnelles}
    
    \chapter{Analyse avec les détails et compléments}
    
    \chapter{Gestion de projet}
    
        \section{Découpage en taches}
        \subsection{Tache 1 : blabla}
        \subsection{Tache 2 : blablabla}
        \section{Planning}
        \subsection{Le planning de recherche}
        \subsection{Le planning de développement}
    
    \chapter{Documents d'installation}
    
    \chapter{Document d'utilisation}
    
    \chapter{Document de test}
    
        \section{Introduction}
            \subsection{Objectifs de test}
        
        \section{Tests unitaires}
            \subsection{Tests du fichier X.c}
            \subsection{Tests du fichier Y.c}
        
        \section{Tests fonctionnels}
            \subsection{Test des fichiers de log/erreurs}
            \subsection{Vérification de la solution}
        
        \section{Tests de performances}
            \subsection{Test du temps d'exécution}
            \subsection{Test d'occupation de mémoire}
        
        \section{Test}
        
            un essai \gls{question}, un autre essai \gls{module}.
            
            voici \gls{lms} et une deuxième fois \gls{lms}.
            
            \gls{opensource}
    
    
    
    
    \weeklyreport{17/09/2018}{
        Je vous envoie ce mail pour vous tenir au courant de l'avancement de mon PR&D. Je cherche toujours une solution pour le problème de la séquence la plus courte. Actuellement, je suis entrain d'analyser deux algorithmes du plus court chemin, à savoir : Johnson's algorithm et Floyd–Warshall algorithm.\\
        Pour Mercredi prochain, je souhaite arriver à la séance en ayant une première version d'algorithme qui sera adaptable au problème.
    }
    \weeklyreport{24/09/2018}{
        J'ai essayé de trouver une bonne approximation au problème. En effet, j'ai implémenté l'algorithme de Floyd-warshall avec une complexité de $O(n^3)$.L'algorithme va me permettre d'évaluer toutes les combinaisons possibles, puis, en déduire une matrice des distances des plus courts chemins entre toutes les paires de sommets. \\
        Celle-ci sera exploité afin de définir la séquence la plus courte en se basant sur des algorithmes d'approximation du TSP (voyageur de commerce).
    
    }
    \weeklyreport{01/10/2018}{
        J'ai crée un répertoire GitHub pour que je puisse bien gérer mon projet et que vous ayez une meilleure visualisation de mon état d'avancement. Voici le lien Git : https://github.com/DevPsksh/PR-D.git .
        Quant au projet, j'ai quelques questions à vous poser. J'aimerais bien convenir d'un Rendez-vous. Je vous remercie d'avance.
    }
    \weeklyreport{08/10/2018}{
        Comme nous avons pu échanger la semaine dernière, j'ai fait des recherches sur les différentes technologies en détails afin d'obtenir les meilleurs résultats en performance. J'ai essayé d'analyser les notions de parallélisme afin de trouver un compromis entre équilibrage des calculs intensifs et minimisation des communications entre différents processus (granularité).\\
        Quant au problème de la séquence la plus courte, je suis parti sur la résolution par brute force, c'est-à-dire mettre en place un algorithme qui génère toutes les permutations possibles, déduit le cout totale de chaque permutation, puis renvoie la séquence la plus courte. La complexité est O(n!).\\
        Je mettrais en place les différentes technologies de parallélisme pour avoir le meilleur temps d'exécution possible.
    }   
    \weeklyreport{15/10/2018}{
        La semaine dernière, j'ai commencé à éditer mon cahier des spécifications et à créer quelques diagrammes de modélisation. En parallèle j'ai implémenté un algorithme qui génère toutes les permutations possibles.\\
        Cette semaine j'essayerais de finir la partie consacrée à l'état d'art pour que nous puissions discuter ensemble à propos des différents points à améliorer.
    }
    
             
    
    \glsaddall
    


\end{document}


